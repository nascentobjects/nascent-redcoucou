/*jslint node: true */

/**
 * Manages all Nascent modules and provides global device APIs.
 * @module Nascent
 */
'use strict';

var EventEmitter = require('events').EventEmitter;
var Nascent = new EventEmitter();
var querystring = require('querystring');
var fs = require('fs');
var spawn = require('child_process').spawn;
var async = require('async');
var Functions = require('./functions');

Nascent.deviceId = '';
Nascent.appId = '';
Nascent.ready = false;
Nascent.modules = {};

var packageInfo = {};

function buildAppId(cb) {
    fs.readFile('nascentpackage.json', 'utf8', function(err, s){
        if (err){
            cb(err, null);
        }else{
            try{
                packageInfo = JSON.parse(s);
                Nascent.appId = packageInfo.app_id;
                cb(null);
            }catch(err){
                cb(err, null);
            }
        }
    });
}

function getOSInfo(cb) {
    var ps = spawn('uname', ['-a']);
    Nascent.os = require('os').type();
    Nascent.isDevice = false;

    ps.stdout.on('data', function(data) {
        var str = '' + data;
        if (str.match(/yocto/)) {
            Nascent.isDevice = true;
        }
        cb();
    });
}

function gatherModules(cb) {
    async.parallel(
        Object.keys(packageInfo.modules).map(function(moduleName) {
            return function(cb) {
                var modDef = packageInfo.modules[moduleName];
                var modReq = require(modDef.type);

                if (modReq.instantiateModule) {
                    // this module needs to be instantiated
                    modReq.instantiateModule(moduleName, modDef.port, function(err, module) {
                        if (err) {
                            cb('Intantiating ' + moduleName + ' error: ' + err);
                        } else {
                            Nascent.modules[moduleName] = module;
                            cb();
                        }
                    });
                } else if (modReq.initializeModule) {
                    // has an initialization function, so call it
                    modReq.initializeModule(moduleName, modDef.port, function(err) {
                        if (err) {
                            cb('Initializing ' + moduleName + ' error: ' + err);
                        } else {
                            Nascent.modules[moduleName] = modReq;
                            cb();
                        }
                    });
                } else {
                    // no initialization or instantiation so just assume we're good
                    Nascent.modules[moduleName] = modReq;
                    cb();
                }
            };
        }),
    function(err) {
        cb(err);
    });
}

// load everything we need to load before emitting either an error or ready
async.series([
    function(callback) { 
       Functions.buildDeviceId(function(err, result) {
            if(err) {
                console.log(err);
            } else {
                Nascent.deviceId = result;
            }
            callback(null);
       });
    },
    buildAppId,
    getOSInfo,
    gatherModules,
], function(err) {
    if (err) {
        Nascent.emit('error', err);
    } else {
        Nascent.ready = true;
        Nascent.emit('ready');
    }
});

function nascentExit() {
    if (process.stdin && process.stdin.setRawMode) {
        process.stdin.pause();
        process.stdin.setRawMode(false);
    }

    Nascent.emit('exit');

    for (var moduleName in Nascent.modules) {
        var m = Nascent.modules[moduleName];

        if (m.cleanupModule) {
            m.cleanupModule();
        }
    }

    process.nextTick(function() {
        spawn('kill', ['-9', process.pid]);
    });
};

// handle keypress of ctrl-c to make sure we actually exit
if (process.stdin && process.stdin.setRawMode) {
    var keypress = require('keypress');
    var spawn = require('child_process').spawn;
    keypress(process.stdin);

    process.stdin.on('keypress', function(ch, key) {
        if (key && key.ctrl && key.name == 'c') {
            process.stdin.pause();
            process.stdin.setRawMode(false);
            nascentExit();
        }

        if (key) {
            Nascent.emit('keypress', key.name);
        }
    });

    process.stdin.setRawMode(true);
    process.stdin.resume();
}

/**
 * Gets the app id of the currently running nascent application.
 * @returns {string} - The app id of the currently running nascent application.
 * @alias module:Nascent.getAppId
 */
Nascent.getAppId = function() {
    return Nascent.appId;
};

/**
 * Gets the unique id of the current device.  This should work regardless of running on a nascent device or some other nodejs framework.
 * @returns {string} - The unique id identifying the current device.
 * @alias module:Nascent.getDeviceId
 */
Nascent.getDeviceId = function() {
    return Nascent.deviceId;
};

/**
 * Determines if the device has passed its initial prep stage where it gathers device/os info and has initiated all modules.
 * @returns {boolean} - true if the device is ready, false otherwise.
 * @alias module:Nascent.isReady 
 */
Nascent.isReady = function() {
    return Nascent.ready;
};

/**
 * Reads global nascent info in the ~/.nascent/info.json file.  
 * This file can be manipulated easily through the nascent bluetooth power button API and read by any nascentpackage.
 * @alias module:Nascent.readInfo 
 */
Nascent.readInfo = function() {
  var infoPath = (process.env.HOME !== '/' ? process.env.HOME : '/root') + '/.nascent/info.json';
  var infoFile = fs.readFileSync(infoPath, {encoding: 'utf8'});
  return JSON.parse(infoFile);
};

/**
 * Overwrites global nascent info in the ~/.nascent/info.json file.  
 * This file can be manipulated easily through the nascent bluetooth power button API and read by any nascentpackage.
 * @param {Object} data - The JSON Object that will become the new info.json data.
 * @alias module:Nascent.writeInfo 
 */
Nascent.writeInfo = function(data) {
  var infoPath = (process.env.HOME !== '/' ? process.env.HOME : '/root') + '/.nascent/info.json';
  fs.writeFileSync(infoPath, JSON.stringify(data), {encoding: 'utf8'});
};

/**
 * Builds a query string suitable for the current device.
 * @todo This should be moved to nascent-cloud.
 * @returns {string} An html url query string section that can be used to provide device information to a REST call; this will not include the starting '?'.
 * @alias module:Nascent.buildQueryString  
 */
Nascent.buildQueryString = function() {
    return 'app_id=' + querystring.escape(Nascent.appId) + '&device_id=' + querystring.escape(Nascent.deviceId);
};

/**
 * Gets an instance to a named module.
 * @param {string} moduleName - The name of the module as it's named in the modules object of nascentpackage.json.
 * @return {Object|null} - null if the module couldn't be found; otherwise, an instance to the module instance of the given name.
 * @alias module:Nascent.getModule  
 */
Nascent.getModule = function(moduleName) {
    if (!(moduleName in Nascent.modules)) {
        return null;
    }

    return Nascent.modules[moduleName];
};

/**
 * Issues a non-fatal warning by a given module.
 * @param {string} moduleName - The name of the module that's giving the warning.
 * @param {string} warning - The warning text/description.
 * @alias module:Nascent.moduleWarning 
 */
Nascent.moduleWarning = function(moduleName, warning) {
    console.log('WARN\t' + moduleName + '\t' + warning);
    Nascent.emit('module_warning', moduleName, warning);
};

/**
 * Issues a fatal error by a given module.
 * @param {string} moduleName - The name of the module that's giving the error.
 * @param {number} errorId - Unique id for this error; the error id should be unique compared to all other errors that can be generated by this module.
 * @param {string} error - The error text/description.
 * @alias module:Nascent.moduleError 
 */
Nascent.moduleError = function(moduleName, errorId, error) {
    console.log('!ERR\t' + moduleName + '\t' + error);
    Nascent.emit('module_error', moduleName, errorId, error);
};

/**
 * Gets a unique id of a module for the current configuration of modules.
 * @param {string} moduleName - The name of the module to look up.
 * @return {number} - A unique id for the module in the current configuration.
 * @throws - An error if the given module name isn't found.
 * @alias module:Nascent.getModuleId
 */
Nascent.getModuleId = function(moduleName) {
    var keys = Object.keys(Nascent.modules);
    for (var a=0; a<keys.length; ++a) {
        if (moduleName === keys[a]) {
            return a;
        } 
    }
    throw 'Couldn\'t find module: ' + moduleName;
};

module.exports = Nascent;
