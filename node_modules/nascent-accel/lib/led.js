'use strict';
var util = require('util');
var EventEmitter = require('events').EventEmitter;
var fs = require('fs');
var async = require('async');

var duty_cycle = 0;

var PWM_GPIOPIN = 13;

var PWM_EXPORT = '/sys/class/pwm/pwmchip0/export';
var PWM_PERIOD = '/sys/class/pwm/pwmchip0/pwm1/period';
var PWM_DUTY = '/sys/class/pwm/pwmchip0/pwm1/duty_cycle';
var PWM_ENABLE = '/sys/class/pwm/pwmchip0/pwm1/enable';

var PWM_PERIOD_VALUE = 1000000;		// 1 mS

function writeSysfs(path, value, callback) {
	//console.log('writing %s to %s', value, path);
	fs.writeFile(path, value, callback);
}

function setPinMux(gpio, value, callback) {
	var path = '/sys/kernel/debug/gpio_debug/gpio' + gpio + '/current_pinmux';
	var writevalue = 'mode' + value;
	writeSysfs(path, writevalue, callback);
}

//direction is 'in' or 'out'
function setPinDir(gpio, direction, callback) {
	var path = '/sys/kernel/debug/gpio_debug/gpio' + gpio + '/current_direction';
	writeSysfs(path, direction, callback);
}

// value is 'low' or 'high'
function setPinValue(gpio, value, callback) {
	var path = '/sys/kernel/debug/gpio_debug/gpio' + gpio + '/current_value';
	writeSysfs(path, value, callback);
}

function Led() {
    var self = this;
    
    async.series([
      function (cb) {
    	  setPinDir(PWM_GPIOPIN, 'out', cb);	// initially set output to gpio driving 0 so LED is off
	  },
      function (cb) {
		  setPinValue(PWM_GPIOPIN, 'low', cb);
		  },
      function (cb) {
		    setPinMux(PWM_GPIOPIN, 0, cb);
		  },
      function (cb) {
		  writeSysfs(PWM_EXPORT, 1, function(err) {
			  cb(null); // this write throws an error if the pin is already exported
		  });
	  },
      function (cb) {
		  writeSysfs(PWM_PERIOD, PWM_PERIOD_VALUE, cb);
	  },
      function (cb) {
		  writeSysfs(PWM_DUTY, duty_cycle, cb);  
	  },
      function (cb) {
		  writeSysfs(PWM_ENABLE, 0, cb); 
	  },
	  ], function(err) {
    	if (err) console.log('error: ', err);
    	self.emit('ready');
	});
}

util.inherits(Led, EventEmitter);

Led.prototype.SetBrightness = function(brightness, callback) {
	
	brightness = (brightness < 0) ? 0 : brightness;
	brightness = (brightness > 100) ? 100 : brightness;
	
	var value = brightness * PWM_PERIOD_VALUE / 100;
	
	/*
	 * Since PWM with duty cycle of 0 is still visible and the PWM enable just shuts off the PWM
	 * and leaves the pin at whatever state it was at we have to switch between PWM and GPIO pinmux
	 * modes in order to force the LED off if duty cycle is set to 0.
	 */
	if (value != duty_cycle) {
		writeSysfs(PWM_DUTY, value, function(err, callback) {
			if (err) return (callback && callback(err));
			
			if (value == 0) {
				// need to set pin to gpio mode and disable the PWM
				duty_cycle = value;
				setPinMux(PWM_GPIOPIN, 0, function(err) {
					if (err) return (callback && callback(err));
					writeSysfs(PWM_ENABLE, 0, callback); 
				});
			} else {
				if (duty_cycle == 0) {
					// need to enable the PWM and set pin to PWM mode
					duty_cycle = value;
					writeSysfs(PWM_ENABLE,1, function(err) {
						if (err) return (callback && callback(err));
						setPinMux(PWM_GPIOPIN, 1, callback); 
					});
					
				} else {
					duty_cycle = value;
					(callback && callback(null));  // already enabled
				}
			}
		});
	} else {
		// set to same value as before
		(callback && callback(null));
	}
}

exports.Led = Led;