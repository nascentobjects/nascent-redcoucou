'use strict';
var util = require('util');
var fs = require('fs');
var EventEmitter = require('events').EventEmitter;
var i2c = require('i2c-bus');
var async = require('async');
var ints = require('./interrupts');
var logger = require('./logger');
var LOG_TAG = 'battery';


/* Design constants for battery */
var BATTERY_CAPACITY = 450,				// mAh
	BATTERY_TERMINATE_VOLTAGE = 3200,	// mV
	BATTERY_TAPER_RATE = 70;			// 65mA in units of 0.1-hr rate

var FUELGAUGE_BUS = 1;
var FUELGAGE_ADDR = 0x55;

/* Registers */
var CONTROL_REG = 0x00,
	TEMPERATURE_REG = 0x02,
	VOLTAGE_REG = 0x04,
	FLAGS_REG = 0x06,
	FULL_CHG_REG = 0x0E,
	AVG_CUR_REG = 0x10,
	STATE_OF_CHARGE_REG = 0x1C,
	DATA_CLASS = 0x3E,
	DATA_BLOCK = 0x3F,
	BLOCK_DATA_CHECKSUM = 0x60,
	BLOCK_DATA_CONTROL = 0x61;

/* Control Reg subcommands */
var CONTROL_STATUS = 0x0000,
    DEVICE_TYPE = 0x0001,
    FW_VERSION = 0x0002,
    SET_CFGUPDATE = 0x0013,
    SEALED = 0x0020,
    SOFT_RESET = 0x0042,
    UNSEAL_KEY =0x8000;

/* Flag register bits */
var	ITPOR = 0x0020,
	SOC1  = 0x0004,
	SOCF  = 0x0002

/* Class 82 data values */
var CLASS82_DESIGN_CAPACITY = 0x4A,
	CLASS82_DESIGN_ENERGY = 0x4C,
	CLASS82_TERMINATE_VOLTAGE = 0x50,
	CLASS82_TAPER_RATE = 0x58;

/* gpios for charger */
var BAT_PGD_N = 46,
	BAT_CHG_N = 47;

var i2c1;
var _emit_battery_state;
var battery_status = 'unknown';

function FuelGauge() {
    var self = this;
    
    /* 
     *   setup i2c connection
     *   verify capacity register and update if not setup
     */
    
    async.series([
      function (cb) {
    	  fs.readFile('/sys/devices/platform/bq24392/device', 'utf8', function (err, data) {
    		  
    		  // if file doesn't exist then assume we are running on RevA hardware
    		  if (err) return cb();
    		  
    		  // update gpios for revB 
    		  BAT_PGD_N = 43;
    		  BAT_CHG_N = 14;
    		  
    		  if (data.trim() == 'NO BATTERY') {
				  logger.info(LOG_TAG, {msg: 'Hardware has no battery'});
    			  // identify that we have no battery
    			  battery_status = 'ac_powered';
    			  // no fuelgauge hardware so skip further initialization
    			  return cb(new Error('NO BATTERY'));
    		  }
    		  
    		  // we're running on hardware with a battery - continue with fuelgauge init
    		  cb();
    	  });
      },
      function (cb) {
	    i2c1 = i2c.open(FUELGAUGE_BUS, cb);
	  },
      function (cb) {
		  self.getFlags( function(err, value) {
			  if (err) return cb(err);
			  
			  if (value & ITPOR) {
				  logger.info(LOG_TAG, {msg: 'Fuel Gauge needs parameters'});
				  self._setupParams(cb);
			  }
			  else 
				  cb();
		  });
	  },
      function (cb) {
  	    ints.on('external_power', _emit_battery_state);
  	    ints.on('charging', _emit_battery_state);
  	    cb();
  	  },
	  ], function(err) {
    	if (err) {
    		logger.info(LOG_TAG, {msg: err.message});
    		if (err.message != 'NO BATTERY')
    			return logger.error(LOG_TAG, {error: err});
    	}
    	
		logger.info(LOG_TAG, {event: 'ready'});
		self._logData(self);
		setInterval(self._logData, 60*1000, self);

		self.emit('ready');
		setTimeout(_emit_battery_state, 50);  // send an initial battery status
		
	});

    
    // called whenever external power or charging state changes or via sendBatteryState()
     _emit_battery_state = function(state) {

    	if (battery_status == 'ac_powered') {
    		self.emit(battery_status);
    		return;    		
    	}
    	
    	_read_gpio(BAT_PGD_N, function(err, data) {
        	if (err) return logger.error(LOG_TAG, {error: err});
        	
        	if (data.trim() == 'high') {
        		// no external power 
        		battery_status = 'discharging';
        		logger.info(LOG_TAG, {event: battery_status});
        		self.emit(battery_status);
        		return;
        	}
        	
        	// have external power - check for charging
        	_read_gpio(BAT_CHG_N, function(err, data) {
            	if (err) return logger.error(LOG_TAG, {error: err});
            	
            	if (data.trim() == 'low') {
            		// currently charging
            		battery_status = 'charging';
            		logger.info(LOG_TAG, {event: battery_status});
            		self.emit(battery_status);
            	} else {
					/*
					 * When power is first applied charger hasn't started charging yet 
					 * but we have external power so there is a phantom full_charge emitted
					 * followed quickly by charging.  It's not trivial to prevent this and also
					 * handle the case where charging has finished before the app runs.
					 * 
					 * FIXME - handle cases where charging never starts, overtemp, etc.
					*/            		
            		battery_status = 'full_charge';
            		logger.info(LOG_TAG, {event: battery_status});
            		self.emit(battery_status);            		            			
            	}
        		
        	});
    		
    	});
    }

}

util.inherits(FuelGauge, EventEmitter);

FuelGauge.prototype._readregister = function(register, callback) {
	i2c1.readWord(FUELGAGE_ADDR, register, callback);
}

FuelGauge.prototype._writeregister = function(register, value, callback) {
	logger.debug(LOG_TAG + ': write 0x%s to 0x%s', value.toString(16), register.toString(16));
	i2c1.writeWord(FUELGAGE_ADDR, register, value, callback);
}

FuelGauge.prototype._readbyte = function(register, callback) {
	i2c1.readByte(FUELGAGE_ADDR, register, callback);
}

FuelGauge.prototype._writebyte = function(register, value, callback) {
	logger.debug(LOG_TAG + ': writebyte 0x%s to 0x%s', value.toString(16), register.toString(16));
	i2c1.writeByte(FUELGAGE_ADDR, register, value, callback);
}

FuelGauge.prototype._readmemword = function(address, callback) {
	var buffer = new Buffer(2);
	i2c1.readI2cBlock(FUELGAGE_ADDR, address, 2, buffer, function(err) {
		if (err) return callback(err);
		callback(null, buffer);
	});
}

FuelGauge.prototype._writememword = function(address, buffer, callback) {
	i2c1.writeI2cBlock(FUELGAGE_ADDR, address, 2, buffer, callback);
}

function _u8_subtract(n1, n2) {
	var value = n1 - n2;
	return (value >= 0) ? value : (value + 256);
}

function _u8_add(n1, n2) {
	var value = n1 + n2;
	return (value > 255) ? (value - 256) : value;
}

function _read_gpio(gpio, cb) {
	var file = util.format('/sys/kernel/debug/gpio_debug/gpio%d/current_value', gpio);
	fs.readFile(file, 'utf8', cb);
}

FuelGauge.prototype._setupParams = function(callback) {
	/* Update fuelgauge params for battery per "Quickstart Guide for bq27421-G1" */
	var self = this;
	var checksum = 0;
	var wr_buf = new Buffer(2);
    async.series([
      function (cb) {
    	  self._writeregister(CONTROL_STATUS, UNSEAL_KEY, cb);
	  },
      function (cb) {
		  self._writeregister(CONTROL_STATUS, UNSEAL_KEY, cb);
	  },
      function (cb) {
		  self._writeregister(CONTROL_STATUS, SET_CFGUPDATE, cb);
	  },
      function (cb) {
		  self._writebyte(BLOCK_DATA_CONTROL, 0, cb);
	  },
      function (cb) {
		  self._writebyte(DATA_CLASS, 82, cb);	// select class 82
	  },
      function (cb) {
		  self._writebyte(DATA_BLOCK, 0, cb);	// select first 32 bytes	
	  },
      function (cb) {
		  self._readbyte(BLOCK_DATA_CHECKSUM, function(err, value) {
			checksum = 0xff - value;
	    	//console.log('checksum = 0x%s', value.toString(16));
	    	cb(err);
	    });
	  },
      function (cb) {
		  self._readmemword(CLASS82_DESIGN_CAPACITY, function(err, buffer) {
			  checksum = _u8_subtract(checksum, buffer[0]);
			  checksum = _u8_subtract(checksum, buffer[1]);
			  var value = buffer.readUInt16BE(0);
			  //console.log('design capacity = %d checksum = 0x%s', value, checksum.toString(16));
			  cb(err);
	    });
	  },
      function (cb) {
		  self._readmemword(CLASS82_DESIGN_ENERGY, function(err, buffer) {
			  checksum = _u8_subtract(checksum, buffer[0]);
			  checksum = _u8_subtract(checksum, buffer[1]);
			  var value = buffer.readUInt16BE(0);
			  //console.log('design energy = %d checksum = 0x%s', value, checksum.toString(16));
			  cb(err);
	    });
	  },
      function (cb) {
		  self._readmemword(CLASS82_TERMINATE_VOLTAGE, function(err, buffer) {
			  checksum = _u8_subtract(checksum, buffer[0]);
			  checksum = _u8_subtract(checksum, buffer[1]);
			  var value = buffer.readUInt16BE(0);
			  //console.log('terminate voltage = %d checksum = 0x%s', value, checksum.toString(16));
			  cb(err);
	    });
	  },
      function (cb) {
		  self._readmemword(CLASS82_TAPER_RATE, function(err, buffer) {
			  checksum = _u8_subtract(checksum, buffer[0]);
			  checksum = _u8_subtract(checksum, buffer[1]);
			  var value = buffer.readUInt16BE(0);
			  //console.log('taper rate = %d checksum = 0x%s', value, checksum.toString(16));
			  cb(err);
	    });
	  },
      function (cb) {
		  wr_buf.writeUInt16BE(BATTERY_CAPACITY, 0);
		  checksum = _u8_add(checksum, wr_buf[0]);
		  checksum = _u8_add(checksum, wr_buf[1]);
		  self._writememword(CLASS82_DESIGN_CAPACITY, wr_buf, cb);
		  //console.log('design capacity = %d checksum = 0x%s', BATTERY_CAPACITY, checksum.toString(16));
	  },
      function (cb) {
		  wr_buf.writeUInt16BE((BATTERY_CAPACITY * 3.7), 0);
		  checksum = _u8_add(checksum, wr_buf[0]);
		  checksum = _u8_add(checksum, wr_buf[1]);
		  self._writememword(CLASS82_DESIGN_ENERGY, wr_buf, cb);
		  //console.log('design energy = %d checksum = 0x%s', (BATTERY_CAPACITY * 3.7), checksum.toString(16));
	  },
      function (cb) {
		  wr_buf.writeUInt16BE(BATTERY_TERMINATE_VOLTAGE, 0);
		  checksum = _u8_add(checksum, wr_buf[0]);
		  checksum = _u8_add(checksum, wr_buf[1]);
		  self._writememword(CLASS82_TERMINATE_VOLTAGE, wr_buf, cb);
		  //console.log('terminate voltage = %d checksum = 0x%s', BATTERY_TERMINATE_VOLTAGE, checksum.toString(16));
	  },
      function (cb) {
		  wr_buf.writeUInt16BE(BATTERY_TAPER_RATE, 0);
		  checksum = _u8_add(checksum, wr_buf[0]);
		  checksum = _u8_add(checksum, wr_buf[1]);
		  self._writememword(CLASS82_TAPER_RATE, wr_buf, cb);
		  //console.log('taper rate = %d checksum = 0x%s', BATTERY_TERMINATE_VOLTAGE, checksum.toString(16));
	  },
      function (cb) {
		  checksum = 0xff - checksum;
		  self._writebyte(BLOCK_DATA_CHECKSUM, checksum, cb);	// write updated checksum
	  },
      function (cb) {
		  self._writeregister(CONTROL_STATUS, SOFT_RESET, cb);	// exit config mode	
	  },
      function (cb) {
		  self._writeregister(CONTROL_STATUS, SEALED, cb);	// seal gauge	
	  }
	  ], function(err) {
    	callback(err);
	});
}

FuelGauge.prototype.getStatus = function(callback) {
	callback(null, battery_status);
}

FuelGauge.prototype.getTemp = function(callback) {
	if (battery_status == 'ac_powered') {
		callback(null, 25.0);
		return;    		
	}

	this._readregister(TEMPERATURE_REG, function(err, value) {
		if (err) return callback(err);
		
		/* convert from 0.1K to 1.0C */
		value -= 2732;
		value /= 10;
		
		callback(null, value);
	});
}

FuelGauge.prototype.getVoltage = function(callback) {
	if (battery_status == 'ac_powered') {
		callback(null, 5.000);
		return;    		
	}
	
	this._readregister(VOLTAGE_REG, function(err, value) {
		if (err) return callback(err);
		
		/* convert from mV to V */
		value /= 1000;
		
		callback(null, value);
	});
}

FuelGauge.prototype.getSOC = function(callback) {
	if (battery_status == 'ac_powered') {
		callback(null, 110);
		return;    		
	}

	this._readregister(STATE_OF_CHARGE_REG, callback);
}

FuelGauge.prototype.getCapacity = function(callback) {
	if (battery_status == 'ac_powered') {
		callback(null, 10000);
		return;    		
	}

	this._readregister(FULL_CHG_REG, callback);
}

FuelGauge.prototype.getAvgCurrent = function(callback) {
	if (battery_status == 'ac_powered') {
		callback(null, 0);
		return;    		
	}

	this._readmemword(AVG_CUR_REG, function(err, buffer) {
		if (err) return callback(err);
		
		/* convert from twos complement */
		var value = buffer.readInt16LE(0);
		
		callback(null, value);
	});
}

FuelGauge.prototype.getFlags = function(callback) {
	if (battery_status == 'ac_powered') {
		callback(null, 0);
		return;    		
	}

	this._readregister(FLAGS_REG, callback);
}

FuelGauge.prototype.sendBatteryState = function() {
	if (_emit_battery_state) _emit_battery_state();
}

FuelGauge.prototype._logData = function (self) {
	var soc,
		voltage,
		temperature,
		Iavg,
		capacity,
		flags;
	
    async.series([
	  function (cb) {
		  self.getSOC(function(err, value) {
		    	if (err) return cb(err);
		    	soc = value;
		    	cb();
		    });
	  },
	  function (cb) {
		  self.getVoltage(function(err, value) {
		    	if (err) return cb(err);
		    	voltage = value;
    	    	cb();
      	    });
	  },
	  function (cb) {
		  self.getTemp(function(err, value) {
		    	if (err) return cb(err);
		    	temperature = value;
		    	cb();
		    });
		  },
	  function (cb) {
			  self.getAvgCurrent(function(err, value) {
		    	if (err) return cb(err);
		    	Iavg = value;
		    	cb();
		    });
		  },
	  function (cb) {
			  self.getCapacity(function(err, value) {
		    	if (err) return cb(err);
		    	capacity = value;
		    	cb();
			 });
		  },
	  function (cb) {
		    self.getFlags(function(err, value) {
		    	if (err) return cb(err);
		    	
	    	flags = value;
	    	
	    	/*
	    	 * Generate low battery messages if not charging.  
	    	 * Use fuelgauge average current to determine charge/discharge - this handles
	    	 * case where there is USB power but the system is consuming more current and 
	    	 * the battery is still discharging
	    	 */    	
	    	if (Iavg <= 0) {
				if (flags & SOCF) {
			    	logger.info(LOG_TAG, {event: 'critically_low_battery'});
			    	self.emit('critically_low_battery');				
				} else if (flags & SOC1) {
			    	logger.info(LOG_TAG, {event: 'low_battery'});
			    	self.emit('low_battery');				
				}	    		
	    	}
	    	

	    	var flagbits = util.format("[%s%s%s%s%s%s%s%s%s%s%s]",
				(flags & 0x8000) ? "OT " : "",
				(flags & 0x4000) ? "UT " : "",
				(flags & 0x0200) ? "FC " : "",
				(flags & 0x0100) ? "CHG " : "",
				(flags & 0x0080) ? "OCV " : "",
				(flags & ITPOR)  ? "ITPOR " : "",
				(flags & 0x0010) ? "UPD " : "",
				(flags & 0x0008) ? "BDET " : "",
				(flags & SOC1)   ? "SOC1 " : "",
				(flags & SOCF)   ? "SOCF " : "",
				(flags & 0x0001) ? "DSG " : "");
		    	
	    		logger.info(LOG_TAG, {SOC: soc, 
	    								V: voltage.toFixed(3),
	    								T: temperature.toFixed(0),
	    								I: Iavg,
	    								Cap: capacity,
	    								flags: flags.toString(16),
	    								flagbits: flagbits
	    								});
		    	cb();
		    });
		  },
	  ], function(err) {
		if (err) {
			logger.error(LOG_TAG, {error: err});
		}
  	});
}


module.exports = new FuelGauge();