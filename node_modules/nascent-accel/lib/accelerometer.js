'use strict';
var util = require('util');
var EventEmitter = require('events').EventEmitter;
var i2c = require('i2c-bus');
var async = require('async');
var ints = require('./interrupts');
var logger = require('./logger');
var LOG_TAG = 'accel';

var ACCEL_BUS = 1;
var ACCEL_ADDR = 0x18;

var CTRL_REG1 = 0x20,
	CTRL_REG3 = 0x22,
	CTRL_REG4 = 0x23,
	CTRL_REG5 = 0x24,
	CTRL_REG6 = 0x25,
	OUT_X_L_REG = 0x28,
	ACT_THS = 0x3E,
	ACT_DUR = 0x3D;

var AUTOINC = 0x80;			// must set MSB of sub address for multi-register transfers

//CTRL_REG3
var I1_DRDY1 = 0x10;		// generate INT1 interrupt on data ready if set

//CTRL_REG5
var BOOT = 0x80;			// Reboot memory content (soft reset)

//CTRL_REG6
var P2_ACT = 0x08;			// Activity interrupt
var P2_LOWACTIVE = 0x02;	// Active low

var i2c1;
var ints_while_asleep = 0,
	want_data = 0;


function Accel() {
    var self = this;
    
    this.current_fullscale = 8;
    this.current_resolution = 12;
    this.current_outputrate = 10;
    var awake = 1;
    
    /* 
     * TODO:
     *   setup i2c connection
     *   set rate and other parameters
     */
    
    async.series([
      function (cb) {
	    i2c1 = i2c.open(ACCEL_BUS, cb);
	  },
	  function (cb) {
			self._writeregister(ACT_THS, 0, cb);		// disable sleep mode
		  },
	  function (cb) {
			self._writeregister(ACT_DUR, 0, cb);		// disable sleep mode
	  },
	  function (cb) {
			self._writeregister(CTRL_REG6, 0, cb);		// disable sleep mode
	  },
      function (cb) {
	    ints.on('accel_int1', _accel_int1);
	    ints.on('accel_int2', _accel_int2);
	    cb();
	  },
	  ], function(err) {
    	if (err) console.log('error: ', err);
		logger.info(LOG_TAG, {event: 'ready'});
    	self.emit('ready');
	});

    function _enable_data_int() {
		self._writeregister(CTRL_REG3, I1_DRDY1, function(err) {
			if (err) {
				console.log ('error enabling data int: ' + err);
			}
		});   	
    }
    
    function _disable_data_int() {
		self._writeregister(CTRL_REG3, 0, function(err) {
			if (err) {
				console.log ('error disabling data int: ' + err);
			}
		});   	
    }

    function _accel_int1(state) {
        if (state) {
        	// When int goes from low to high we have a sample - go get it
        	
            var buffer = new Buffer(6);
            i2c1.readI2cBlock(ACCEL_ADDR, (OUT_X_L_REG|AUTOINC), 6, buffer, function(err) {
            	if (err) {
            		self.emit('error', err);
            		return;
            	}
            	
        		if ((awake || ints_while_asleep) && want_data) {
            		var xyz = [];
            		xyz[0] = self._scaleaxis(buffer.readInt16LE(0));
            		xyz[1] = self._scaleaxis(buffer.readInt16LE(2));
            		xyz[2] = self._scaleaxis(buffer.readInt16LE(4));
        			self.emit('sample', xyz);
        		}
            });
        	
        }
    }

    function _accel_int2(state) {
        if (state) {
        	// When int2 goes from low to high we are in idle mode
    		awake = 0;
			if (want_data && !ints_while_asleep) {
				_disable_data_int();
			}
			logger.info(LOG_TAG, {event: 'quiet'});
    		self.emit('sleep');
    	} else {
			if (want_data && !ints_while_asleep) {
				_enable_data_int();
			}
			logger.info(LOG_TAG, {event: 'active'});
    		self.emit('wake');
    		awake = 1;
    	}

    }
    
    
    self.on('newListener', function(event) {
    	if (event == 'sample') {
        	_enable_data_int();
        	want_data = 1;   		
    	}
    })
    
    self.on('removeListener', function(event) {
    	if (event == 'sample') {
			_disable_data_int();
			want_data = 0;
    	}
    })
    
}

util.inherits(Accel, EventEmitter);

Accel.prototype._readregister = function(register, callback) {
	
	i2c1.readByte(ACCEL_ADDR, register, callback);
}

Accel.prototype._writeregister = function(register, value, callback) {
	
    //console.log('_writeregister: 0x%s to reg 0x%s', value.toString(16), register.toString(16));
    
	i2c1.writeByte(ACCEL_ADDR, register, value, callback);
}

Accel.prototype._scaleaxis = function(value) {
	var self = this;
	
	/* convert from left justified twos complement to g's */
	value /= 0x8000;
	
	return (value *= self.current_fullscale);
}

Accel.prototype.availableOutputRates = function() {
	return [5376,1620,1344,400,200,100,50,25,10,1];
}

Accel.prototype.availableFullScales = function() {
	return [16,8,4,2];
}

Accel.prototype.availableResolutions = function() {
	return [12,10,8];
}

Accel.prototype.setMode = function(rate, fullscale, resolution, callback) {
	
	var self = this;
	/* check for valid values */
	if (this.availableOutputRates().indexOf(rate) < 0) {
		return callback(new Error('accel: invalid rate: ' + rate));
	}
	if (this.availableFullScales().indexOf(fullscale) < 0) {
		return callback(new Error('accel: invalid scale: ' + fullscale));
	}
	if (this.availableResolutions().indexOf(resolution) < 0) {
		return callback(new Error('accel: invalid resolution: ' + resolution));
	}
	
	/* higher rates have resolution limitations */
	if ((rate == 1344) && (resolution == 8)) {
		return callback(new Error('accel: 1344 Hz 8 bit is invalid'));	
	}
	if ((rate > 1344) && (resolution != 8)) {
		return callback(new Error('accel: only 8 bit resolution is valid for 1620/5376 Hz'));		
	}

	/* setup control registers */
	var reg1 = 0x07;  // enable all axis
	switch (rate) {
		case 1: reg1 |= 1 << 4; break;
		case 10: reg1 |= 2 << 4; break;
		case 25: reg1 |= 3 << 4; break;
		case 50: reg1 |= 4 << 4; break;
		case 100: reg1 |= 5 << 4; break;
		case 200: reg1 |= 6 << 4; break;
		case 400: reg1 |= 7 << 4; break;
		case 1620: reg1 |= 8 << 4; break;
		case 1344: reg1 |= 9 << 4; break;
		case 5376: reg1 |= 9 << 4; break;
	}
	if (resolution == 8) 
		reg1 |= 0x08;  // LPen bit
	
	var reg4 = 0x00;
	switch (fullscale) {
		case 2: reg4 |= 0 << 4; break;
		case 4: reg4 |= 1 << 4; break;
		case 8: reg4 |= 2 << 4; break;
		case 16: reg4 |= 3 << 4; break;
	}
	if (resolution == 12) 
		reg4 |= 0x08;  // HR bit
	
	this._writeregister(CTRL_REG1, reg1, function(err) {
		if (err) return callback(err);

		self._writeregister(CTRL_REG4, reg4, function(err) {
			if (err) return callback(err);

			self._writeregister(CTRL_REG3, 0, function(err) {
				if (err) return callback(err);

				self.current_fullscale = fullscale;
			    self.current_resolution = resolution;
			    self.current_outputrate = rate;
			    callback(null);
			});
		});
		
	});
}

Accel.prototype.setActivity = function(threshold, duration, data_while_asleep, callback) {
	
	var self = this;
	
	ints_while_asleep = data_while_asleep;

	self._writeregister(ACT_THS, threshold, function(err) {
		if (err) return callback(err);

		self._writeregister(ACT_DUR, duration, function(err) {
			if (err) return callback(err);

			self._writeregister(CTRL_REG6, P2_ACT, function(err) {
				return callback(err);

			});
		});
	});
}


exports.Accel = Accel;
